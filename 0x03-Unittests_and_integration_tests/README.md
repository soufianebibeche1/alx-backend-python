# 0x03. Unittests and Integration Tests

## Overview
This project focuses on understanding and implementing unit tests and integration tests in Python. You will learn the differences between these testing types, common testing patterns such as mocking, parameterization, and fixtures, and how to apply these concepts to ensure the reliability and functionality of your code.

## Learning Objectives
By the end of this project, you should be able to:
- Differentiate between unit tests and integration tests.
- Use common testing patterns including mocking, parameterization, and fixtures.
- Write effective unit tests that cover standard inputs and edge cases.
- Implement integration tests to verify end-to-end code interactions.

## Requirements
- All files are interpreted/compiled on Ubuntu 18.04 LTS using Python 3.7.
- Files should end with a new line.
- The first line of all files should be `#!/usr/bin/env python3`.
- A `README.md` file at the root of the project folder is mandatory.
- Code should follow the `pycodestyle` style guide (version 2.5).
- All files must be executable.
- All modules should have documentation.
- All classes should have documentation.
- All functions, both inside and outside classes, should have documentation.
- Documentation should be a real sentence explaining the purpose of the module, class, or method.
- All functions and coroutines must be type-annotated.

## Project Structure
- `utils.py`: Contains utility functions to be tested.
- `client.py`: Contains client functions that will be tested.
- `fixtures.py`: Contains fixture data for testing.

## Testing Instructions
